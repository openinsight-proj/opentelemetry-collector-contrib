// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0
package main

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

const (
	maxDependabotUpdates = 220
	dependabotHeader     = `# File generated by "make gendependabot"; DO NOT EDIT.

`
)

type dependabotSchedule struct {
	Interval yaml.Node `yaml:"interval"`
	Day      yaml.Node `yaml:"day"`
}

type dependabotUpdate struct {
	PackageEcosystem yaml.Node          `yaml:"package-ecosystem"`
	Directory        yaml.Node          `yaml:"directory"`
	Schedule         dependabotSchedule `yaml:"schedule"`
	Priority         int                `yaml:"-"`
}

type dependabotData struct {
	Version int                `yaml:"version"`
	Updates []dependabotUpdate `yaml:"updates"`
}

func makePriority(status *Status) int {
	// not an internal component such as pkg/**, and no distributions:
	if (status.Class == "receiver" || status.Class == "processor" || status.Class == "exporter" || status.Class == "connector" || status.Class == "extension" || status.Class == "cmd") &&
		len(status.Distributions) == 0 && status.Class != "" {
		return 1
	}
	// start with a score of 2
	maxScore := 2
	for stability := range status.Stability {
		switch stability {
		case "deprecated": // stay with 2
		case "unmaintained":
			return 1
		case "alpha":
			if maxScore < 3 {
				maxScore = 3
			}
		case "beta":
			if maxScore < 4 {
				maxScore = 4
			}
		case "stable":
			if maxScore < 5 {
				maxScore = 5
			}
		}
	}
	return maxScore
}

func newDependabotUpdate(directory string, priority int) dependabotUpdate {
	return dependabotUpdate{
		PackageEcosystem: yaml.Node{Value: "gomod", Style: yaml.DoubleQuotedStyle, Kind: yaml.ScalarNode},
		Directory:        yaml.Node{Value: "/" + directory, Style: yaml.DoubleQuotedStyle, Kind: yaml.ScalarNode},
		Schedule: dependabotSchedule{
			Interval: yaml.Node{Value: "weekly", Style: yaml.DoubleQuotedStyle, Kind: yaml.ScalarNode},
			Day:      yaml.Node{Value: "wednesday", Style: yaml.DoubleQuotedStyle, Kind: yaml.ScalarNode},
		},
		Priority: priority,
	}
}

type dependabotGenerator struct {
}

func (dg dependabotGenerator) generate(data *githubData) error {
	dependabotData := data.dependabotData
	sort.Slice(dependabotData.Updates, func(i, j int) bool {
		return dependabotData.Updates[i].Priority > dependabotData.Updates[j].Priority
	})
	removed := dependabotData.Updates[maxDependabotUpdates:]
	dependabotData.Updates = dependabotData.Updates[:maxDependabotUpdates]
	if len(removed) > 0 {
		sort.Slice(removed, func(i, j int) bool {
			return strings.Compare(removed[i].Directory.Value, removed[j].Directory.Value) < 0
		})
		fmt.Printf("The following modules were not added to Dependabot to keep within limits of %d\n", maxDependabotUpdates)
		for _, update := range removed {
			fmt.Printf("  - %q\n", update.Directory.Value)
		}
	}

	sort.Slice(dependabotData.Updates, func(i, j int) bool {
		return strings.Compare(dependabotData.Updates[i].Directory.Value, dependabotData.Updates[j].Directory.Value) < 0
	})

	var yamlContents bytes.Buffer
	encoder := yaml.NewEncoder(&yamlContents)
	encoder.SetIndent(2)
	err := encoder.Encode(dependabotData)
	if err != nil {
		return err
	}
	err = os.WriteFile(filepath.Join(".github", "dependabot.yml"), append([]byte(dependabotHeader), yamlContents.Bytes()...), 0600)
	return err
}
